#!/usr/bin/python3


from ..agents import Agent

__all__ = ['GuardianAngel']

class GuardianAngel(Agent,object):
	"""
	A GuardianAngel is a bot: an agent whose decisions are generated by
	an algorithm.
	
	- GuardianAngels don't output clues sponteneously; only when prompted to do so
	by God.
	
	- GuardianAngels can't reinforce or weaken each other: they can take feedback
	only on behalf of normal agents or god. (or a special agent such as a
	Knower() instance, which is a training machine for semanticsky.)
	"""
	
	guardianid = 0
	
	def __init__(self,algorithm,supervisor,ghost = False,whisperer = False):
		super().__init__(algorithm.__name__,supervisor)
		
		from semanticsky import DEFAULTS
		from copy import deepcopy
		self.clear_all() # initializes various properties
		
		self.supervisor = supervisor
		self.algorithm = algorithm
		self.__doc__ = self.algorithm.__doc__
		GuardianAngel.guardianid += 1 # counts the GA's spawned
		self.ID = deepcopy(GuardianAngel.guardianid)
		
		if whisperer:
			self.makewhisperer()
			
	def __str__(self):
		return "< GuardianAngel {} of {}>".format(self.name,self.supervisor)
		
	def __repr__(self):
		from semanticsky.tests import wrap
		return wrap("< GuardianAngel {} >".format(self.name),'brightcyan')
	
	def __eq__(self,other):
		"""
		Returns true iff the NAME of the two angels is the same; that's
		equivalent to 'having the same algorithm'. 
		"""
		
		try:
			if self.name == other.name or self.algorithm == other.algorithm:
				return True
		except BaseException:
			pass
			
		return False
	
	def __hash__(self):
		return hash(self.ID)
	
	def shortname(self):
		"""
		Returns a max 4-characters name.
		"""
		from.utils.algorithms import Algorithm as alg
		
		algs = alg.builtin_algs
		
		transdict = {algs.tf_weighting : 'tf',
			algs.tf_idf_weighting: 'idf',
			algs.coo_dicts_overlap_v1 : 'coo1',
			algs.coo_dicts_overlap_v2 : 'coo2',
			algs.coo_dicts_neighbour : 'cooN',
			algs.coo_dicts_extended_neighbour: 'Ecoo',
			algs.tag_overlap:'tago',
			algs.extended_name_comparison: 'Enam', 
			algs.naive_name_comparison: 'name',
			algs.tag_similarity_naive: 'tags',
			algs.tag_similarity_extended : 'Etag',
			algs.naive_core_overlap : 'core',
			algs.extended_core_overlap : 'corE',
			algs.someonesuggested: 'know'}
			
		return transdict.get(self.algorithm,self.name[0:5])	
	
	def clear_all(self):
		"""
		(Re)initializes most records.
		"""
		from .utils import BeliefBag
		from copy import deepcopy
		from semanticsky import DEFAULTS
		
		self.zero = 0									# keeps track of 0-valued evaluations produced
		self.nonzero = 0								# keeps track of nonzero evaluations
		self.beliefbag = BeliefBag(self)					# will contain all beliefs and handle their weighting, equalizing...
		self.stats = deepcopy(DEFAULTS['agent_base_stats'])	# stats such as trustworthiness (absolute and contextual)...
		self.stats.update(DEFAULTS['angel_base_stats']) # we override the agent-level stats with the defaults provided
		self.produced_feedback = set()					# the name says it all
		self.received_feedback = {}						# idem
		self.clues = []									# will host all produced clues
		self.consulted = False							# this flag goes true iff self.evaluate_all is called on god's sky's full cloudlist (preferably through self.consult() or God.consult(self)).
	
	# consultation and evaluation functions
	def consult(self):
		self.supervisor.consult(self)
			
	def evaluate(self,what,silent = False,consider = True):
		"""
		'what' must be a pair-of-clouds instance, for the moment. Best is
		always to use whatever default is set at 
		semanticsky.skies.clouds.core.pair. That is what every agent and sky
		here uses and should use.
		
		Returns the clue (whose 'autoconsider' kwarg is set to the kwarg 
		'consider').
		
		In silent mode, only the evaluation is returned, and no clue is 
		produced.
		"""
		
		from semanticsky import DEFAULTS
		
		# step 1: get the evaluation (self.algorithm output) for *what*
		if what in self.beliefbag:
			evaluation = self.beliefbag[what]
		else:
			try:
				evaluation = self.algorithm(*what) # I love this part
				
				if DEFAULTS["log_zero_evaluations"]: 	self.beliefbag[what] = evaluation # stores the evaluation # now also if it's zero! 
				else:								# check whether we have to record 0 evaluations (if True, it's a VERY SPARSE matrix. 
											# maybe we could use a sparse.CSR to store it efficiently?)
					if evaluation > 0:
						self.beliefbag[what] = evaluation
				
			except BaseException as e:
				print('ERROR: what == ',what)
				raise e
		
		# step 2: what to do if evaluation is zero
		if not evaluation > 0:
			self.zero += 1
			if DEFAULTS['log_zero_evaluations']: # check the DEFAULT for storing zero evaluations			
				return 0 # no clue is produced!
			else:
				pass # do nothing and go on: if silent is true, we'll return the evaluation and stop anyway; but if silent is false, we'll spawn a clue whose value is 0
		else:
			self.nonzero += 1		
		
		if silent:
			return evaluation
			
		# step 3: spawn a clue.
		
		from semanticsky.clues import Clue
		return Clue(what,evaluation,self,autoconsider = consider,trace = 'GuardianAngel.evaluate',supervisor = self.supervisor)
		
	def evaluate_all(self,iterpairs = None,express = True,verbose = True):
		"""
		Tells the GuardianAngel to do a full evaluation:
		evaluates each pair of clouds in the iterable (subscriptable).
		
		evaluate_all(express = False) + express() is equivalent
		to evaluate_all()
		
		Iterpairs defaults to the supervisors' sky's full 2-permutations 
		of clouds. May take long!
		"""
		
		if self.beliefbag and iterpairs is None:
			print( """Warning("Warning: evaluation wasn't empty!" Returning...)""")
			return
		if self.clues and express == True:
			print( """Warning("Warning: clues nonempty!")\nsetting express to False.""")
			express = False
		
		import semanticsky
		if verbose:	
			vb = semanticsky.DEFAULTS['verbosity']
		else:
			vb = 0
		if vb > 0:
			print('\nSummoning {}...'.format( semanticsky.tests.wrap(str(self),'brightred')) )
		
		if iterpairs is None:
			pairlist = tuple(self.supervisor.sky.iter_pairs())
			if express:
				self.consulted = True
		else:
			pairlist = iterpairs
				
		li = len(pairlist)
		
		if vb > 1: print('\n>evaluating its way through a {}-item cloud pairlist.<'.format(li))
		
		if vb > 1: bar = semanticsky.tests.ProgressBar(li,title = '{} :: Evaluation'.format(self.shortname()) )
		for pair in pairlist:
			
			if vb > 1:
				bar()

			self.evaluate(pair,silent = False if express else True) # silent: no clue is spawned
		
		if vb >0 :
			print()
		
		return

	def express(self,number = 0,verbose = True):
		"""
		Transforms into clues all the evaluations the angel has in its 
		beliefbag.
		"""
		
		self.consulted = True
		
		from semanticsky import DEFAULTS
		if verbose:
			vb = DEFAULTS['verbosity']
		else:
			vb = 0
		
		allbeliefs = tuple(self.beliefbag.keys())
		
		if not number: 
			number = len(allbeliefs)
		
		if not number > 0:
			if vb > 0:
				print('Nothing to express.')
			return False
		
		if vb > 0: print(repr(self),' is expressing...')
		if vb > 1: 
			from semanticsky.tests import ProgressBar
			bar = ProgressBar(number,title = '{} :: Expressing'.format(self.shortname()))
		
		for i in range(number):
			pair = allbeliefs[i]
			if vb > 1: bar()
			
			value = self.beliefbag[pair]
			from semanticsky.clues import Clue
			clue = Clue(pair,value,self,trace = 'GuardianAngel.evaluate',supervisor = self.supervisor)
		
		print()
		return True
	
	def believes(self,belief):  # full pipeline: use this!
		"""
		Full belief pipeline. If equalization and weighting are on and
		available (the belief is of a ctype for which a contextual_tw is
		available, and DEFAULTS['equalization'] is True), returns the equalized
		and then weighted value for self.beliefbag[belief].
		Else, returns the LAST value available in the pipeline. (I.e. if weighting
		is available but equalization is not, returns the weighted.)
		
		0 - raw belief value (algorithm output)
		1 - equalized value
		2 - weighted value 	## thus, angel.beliefbag.toplevel() will return the same as
							## angel.beliefbag.weighted_belief_set()
		
		"""
		if not self.beliefbag[belief] > 0:
			return self.beliefbag[belief] # if it's zero, it won't change by weighting or equalizing. Right?
		
		from semanticsky import DEFAULTS
		if DEFAULTS['equalization']:
			value = self.beliefbag.equalized(belief) # fetch the equalized value if available
		else:
			value = self.beliefbag[belief] # returns 0 if item wasn't evaluated, 0.0 if it was but the evaluation was null
		
		return self.weighted(belief,value) # agent level
	
	def trusted(self):
		"""
		Prints nicely the god.trusts(self) outcome.
		"""
		
		return self.god.trusts(self,local = False)
	
	def agrees(self,other = None):
		"""
		Returns a count of the percent of links he agrees about with all
		other angels.
		"""
		
		if not other:
			others = self.supervisor.guardianangels
		
		if other:
			if not isinstance(other,list):
				others = [other]
		
		out = {}
		
		for angel in others:
			
			
			if angel is self:
				continue

			outangel = {}
			
			pairsagreedon = 0
			agreement = 0
			for pair in angel.evaluation:
				if self.evaluation.get(pair):
					myeval = self.evaluation[pair]
					hiseval = angel.evaluation[pair]
					agreement += min(myeval,hiseval)
					pairsagreedon += 1
					
			totpairs = len(set(angel.evaluation).union(set(self.evaluation)))
	
			outangel['average agreement'] = agreement / totpairs
			outangel['pairs agreed upon'] = pairsagreedon
			
			out[angel] = outangel
		
		return out
	
	def reset_all_but_stats(self):
		"""
		returns a new guardian angel with self's stats and everything else
		clean.
		"""
		
		stats = deepcopy(self.stats)
		
		newga = GuardianAngel(self.algorithm,self.supervisor)
		newga.stats = stats
		return newga
		
	# expertises
	def lookup_expertises(self):
		"""
		Tries to guess which areas he is (most) expert in.
		At the moment, simply updates self.stats['expertises'] with
		whatever he is deemed to be confident enough (relative_tw).
		Enough == 'higher than average'.
		"""
		
		avg = sum(self.stats['relative_tw'].values()) / len(self.stats['relative_tw']) if self.stats['relative_tw'] else 0
		
		for tw,value in self.stats['relative_tw'].items():
			if value > avg:
				if tw not in self.stats['expertises']:
					from semanticsky.tests import crop_at_nonzero
					self.stats['expertises'][tw] = crop_at_nonzero(value,4)
		
		return True
	
	def regrets(self,only_on_true_links = False):
		"""
		Computes the regrets of the toplevel belief pipeline available:
		that is, the self.believes output for all the beliefset.
		"""
		
		from .utils import regret
		from semanticsky.tests import diff
		
		return regret(self.beliefbag.toplevel() ,self.supervisor.knower.beliefbag)
