#!/usr/bin/python3

from .utils import belief_rules
from copy import deepcopy
from .utils import Feedback
from ..agents import Agent

class GuardianAngel(Agent,object):
	"""
	A GuardianAngel is a bot: an agent whose decisions are generated by
	an algorithm.
	
	- GuardianAngel don't output clues sponteneously; only when prompted to do so
	by God.
	
	- GuardianAngel can't reinforce or weaken each other: they can take feedback
	only on behalf of normal agents or god.
	"""
	
	guardianid = 0
	
	def __init__(self,algorithm,supervisor,ghost = False,whisperer = False):
		super().__init__(algorithm.__name__,supervisor)
		
		self.supervisor = supervisor
		
		self.zero = 0
		self.nonzero = 0
		self.evaluation = {}
		self.algorithm = algorithm
		self.stats['trustworthiness'] = 1 # by default, an algorithm's trustworthiness is always one.
		self.clues = [] # Clues objects
		self.consulted = False
		self.logs = []
		self.ghost = ghost
		self.__doc__ = self.algorithm.__doc__
		
		GuardianAngel.guardianid += 1 # counts the GA's spawned
		self.ID = deepcopy(GuardianAngel.guardianid)
		
		if whisperer:
			self.makewhisperer()
			
	def __str__(self):
		return "< GuardianAngel {} of {}>".format(self.name,self.supervisor)
		
	def __repr__(self):
		from semanticsky.tests import wrap
		return wrap("< GuardianAngel {} >".format(self.name),'brightcyan')
	
	def __eq__(self,other):
		"""
		Returns true iff the NAME of the two angels is the same; that's
		equivalent to 'having the same algorithm'. 
		"""
		
		try:
			if self.name == other.name or self.algorithm == other.algorithm:
				return True
		except BaseException:
			pass
			
		return False
	
	def __hash__(self):
		return hash(self.ID)
	
	def shortname(self):
		"""
		Returns a max 4-characters name.
		"""
		import semanticsky.agents.utils.algorithms as algs
		
		transdict = {algs.tf_weighting : 'tf',
			algs.tf_idf_weighting: 'idf',
			algs.coo_dicts_overlap_v1 : 'coo1',
			algs.coo_dicts_overlap_v2 : 'coo2',
			algs.coo_dicts_neighbour : 'cooN',
			algs.coo_dicts_extended_neighbour: 'Ecoo',
			algs.tag_overlap:'tago',
			algs.extended_name_comparison: 'Enam', 
			algs.naive_name_comparison: 'name',
			algs.tag_similarity_naive: 'tags',
			algs.tag_similarity_extended : 'Etag',
			algs.naive_core_overlap : 'core',
			algs.extended_core_overlap : 'corE',
			algs.someonesuggested: 'know'}
			
		return transdict.get(self.algorithm,self.name[0:5])	
	
	# consultation and evaluation functions
	def consult(self):
		self.supervisor.consult(self)
			
	def evaluate(self,what,silent = False,consider = True):
		"""
		what must be a pair-of-clouds instance, for the moment.
		
		returns the clue.
		
		In silent mode, only the evaluation is returned. Useful for when
		god wants to choose between its GuardianAngel the best judgement
		before taking it into account.
		"""
		
		if what in self.evaluation:
			evaluation = self.evaluation[what]
		
		else:
			try:
				evaluation = self.algorithm(*what)
			except BaseException as e:
				print('what == ',what)
				raise e
		
		if not evaluation > 0:
			self.zero += 1
			return 0
		else:
			self.nonzero += 1		
		
		self.evaluation[what] = evaluation # stores the evaluation
		
		if silent:
			return evaluation
		
		from semanticsky.clues import Clue
		return Clue(what,evaluation,self,autoconsider = consider,trace = 'GuardianAngel.evaluate',supervisor = self.supervisor)
		
	
	def evaluate_all(self,iterpairs = None,express = True,verbose = True):
		"""
		Tells the GuardianAngel to do a full evaluation:
		evaluates each pair of clouds in the iterable (subscriptable).
		
		evaluate_all(express = False) + express() is equivalent
		to evaluate_all()
		"""
		
		if self.evaluation:
			print( """Warning("Warning: evaluation wasn't empty!" Returning...)""")
			return
		if self.clues and express == True:
			print( """Warning("Warning: clues nonempty!")\nsetting express to False.""")
			express = False
			
		if verbose: 
			from tests import wrap
			print('\nSummoning {}...'.format( wrap(str(self),'brightred')) )
		
		if iterpairs is None:
			pairlist = tuple(self.supervisor.sky.iter_pairs())
			self.consulted = True
		else:
			pairlist = iterpairs
				
		li = len(pairlist)
		
		print('\n>evaluating its way through a {}-item cloud pairlist.<'.format(li))
		
		i = 0
		bar = semanticsky.tests.ProgressBar(li,title = '{} :: Evaluation'.format(self.shortname()) )
		for pair in pairlist:
			
			if verbose:
				bar()
			
			silence = False if express else True
			self.evaluate(pair,silent = silence) # silent: no clue is spawned
				
				
			i += 1
	
	def revaluate(self,what,express = True):
		"""
		"""
		if clue not in self.clues:
			raise Warning('Not a clue of mine: {}. I am {}.'.format(clue,self))
			return None
			
		if clue.value > 0:
			self.nonzero -= 1
		
		clue.delete()
		self.evaluate(clue.about,consider = express)
		self.supervisor.reassess(clue)
					
	def revaluate_all(self,iterable_clouds = None, express = True, verbose = True):
		"""
		Deletes all angel's clues and reruns an evaluate_all on the clues' abouts
		"""
		
		allinks = tuple(clue.about for clue in self.clues)
		
		customiter = iter(allinks)
			
		for clue in self.clues:
			clue.delete()
		
		self.evaluate_all(customiter(allinks),express,verbose)
		
		self.supervisor.reassess(allinks) # makes god check again
		
	def express(self,number = 0):
		"""
		Transforms into clues the evaluations previously produced.
		"""
		
		if not number: 
			number = len(self.evaluation.keys())
		
		if not len(self.evaluation.keys()) > 0:
			print('Nothing to express.')
			return False
		
		print(repr(self),' is expressing...')
		bar = ss.ProgressBar(number,title = '{} :: Expressing'.format(self.shortname()))
		for i in range(number):
			pair = list(self.evaluation.keys())[i]
			bar()
			
			value = self.evaluation[pair]
			clue = Clue(pair,value,self,trace = 'GuardianAngel.evaluate',supervisor = self.supervisor)
		print()
		return True

	def equalize(self,equalizer_override = False, antigravity_override = False,override_kwargs = {}):
		"""
		Produces, and loads to self.equalized_evaluation an equalized
		belief set. Overrides can be given to differentiate between angels'
		equalization or antigravity point getting procedures, in case there 
		are known different biases. If they are given, all subsequent calls
		to equalize will use these rules, unless new overrides are provided.
		"""
		
		if equalizer_override:
			self.equalizer_override = equalizer_override
			
		if hasattr(self,'equalizer_override'):
			equalizer = self.equalizer_override
		else:
			equalizer = default_equalizer
		
		if antigravity_override:
			self.antigravity_override = antigravity_override
			
		if hasattr(self,'antigravity_override'):
			antigrav = self.antigravity_override
		else:
			antigrav = None
		
		#### EQUALIZATION ####
			
		self.equalized_evaluation = equalizer(	self.evaluation, # the belief set to be equalized
												self,antigravity_override = antigrav, # a custom antigravity getter, in case...
												**override_kwargs)  # possibly, some override arguments such as 'factor', 'top', 'maxbonus', depending
																	# on the equalization algorithm
		#### ------------ ####
		
		return True
	
	def belief_without_feedback(self,pair):
		return self.evaluation.get(pair,0)
	
	def belief_with_feedback(self,pair):
		
		ctype = ss.utils.ctype(pair)
		contextual_tw = self.stats['relative_tw'].get(ctype,self.trustworthiness)
		
		return self.evaluation.get(pair,0) * contextual_tw
		
	def reltrust(self,ctype):
		"""
		Returns the relative trustworthiness about clues of type ctype.
		If there is no data on that, returns 0.
		"""
		return self.stats['relative_tw'].get(ctype,0)
	
	def trusted(self):
		"""
		Prints nicely the god.trusts(self) outcome.
		"""
		
		return self.god.trusts(self,local = False)
	
	# comparison functions
	def agrees(self,other = None):
		"""
		Returns a count of the percent of links he agrees about with all
		other angels.
		"""
		
		if not other:
			others = self.supervisor.guardianangels
		
		if other:
			if not isinstance(other,list):
				others = [other]
		
		out = {}
		
		for angel in others:
			
			
			if angel is self:
				continue

			outangel = {}
			
			pairsagreedon = 0
			agreement = 0
			for pair in angel.evaluation:
				if self.evaluation.get(pair):
					myeval = self.evaluation[pair]
					hiseval = angel.evaluation[pair]
					agreement += min(myeval,hiseval)
					pairsagreedon += 1
					
			totpairs = len(set(angel.evaluation).union(set(self.evaluation)))
	
			outangel['average agreement'] = agreement / totpairs
			outangel['pairs agreed upon'] = pairsagreedon
			
			out[angel] = outangel
		
		return out
	
	def reset_all_but_stats(self):
		"""
		returns a new guardian angel with self's stats and everything else
		clean.
		"""
		
		stats = deepcopy(self.stats)
		
		newga = GuardianAngel(self.algorithm,self.supervisor)
		newga.stats = stats
		return newga
		
	# expertises
	def lookup_expertises(self):
		"""
		Tries to guess which areas he is (most) expert in.
		At the moment, simply updates self.stats['expertises'] with
		whatever he is deemed to be confident enough (relative_tw).
		Enough == 'higher than average'.
		"""
		
		avg = sum(self.stats['relative_tw'].values()) / len(self.stats['relative_tw']) if self.stats['relative_tw'] else 0
		
		for tw,value in self.stats['relative_tw'].items():
			if value > avg:
				if tw not in self.stats['expertises']:
					self.stats['expertises'][tw] = crop_at_nonzero(value,4)
		
		return True
	
	def regrets(self,only_on_true_links = False):
		
		regret = ss.regret
		diff = ss.diff
		
		if only_on_true_links:
			# returns the regret computed only on the true beliefs (those which are known to be true)
			return regret(  {b:self.belief_with_feedback(b) for b in self.supervisor.knower.evaluation} ,self.supervisor.knower.evaluation  )
			
		# we can't give regret on all the beliefs: otherwise, when loading evaluation from file, we'll give full regret.
		return regret( {b:self.belief_with_feedback(b) for b in [clue.about for clue in self.clues]} ,self.supervisor.knower.evaluation)
	
